import { Component, OnInit } from '@angular/core';
import {
  of,
  concat,
  merge,
  interval,
  zip,
  Observable,
  from,
  timer
} from 'rxjs';
import {
  map,
  filter,
  delay,
  pluck,
  mergeMap,
  concatMap,
  switchMap,
  first,
  startWith,
  endWith
} from 'rxjs/operators';
import { ObserveOnOperator } from 'rxjs/internal/operators/observeOn';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  screenConsoleText = '';
  obs1$: Observable<number>;
  obs2$: Observable<number>;

  ngOnInit() {
    this.obs1$ = this.createObservableThatYieldsDataAtIntervals(
      [11, 12, 13, 14, 15, 16],
      1000
    );
    this.obs2$ = this.createObservableThatYieldsDataAtIntervals(
      [21, 22, 23],
      2000
    );
  }

  formatTime(t: Date) {
    function pad(n: number) {
      return n.toString().padStart(2, '0');
    }
    return `[${pad(t.getHours())}:${pad(t.getMinutes())}:${pad(
      t.getSeconds()
    )}] `;
    // .${pad(t.getMilliseconds())}] `;
  }

  logToScreen(message: any) {
    const now = new Date();
    this.screenConsoleText += this.formatTime(now);
    this.screenConsoleText += message;
    this.screenConsoleText += '\n';
  }

  /**
   * Creates an observer that yields data
   * at regular intervals, given by the "period" parameter
   *
   * @param period The interval between each data generated by the observer.
   */
  createObservableThatYieldsDataAtIntervals<T>(
    data: Array<T>,
    period: number
  ): Observable<T> {
    const timer1$ = interval(period);
    const data$ = from(data);
    // Creates a combined observer that yields each element in "data$" at
    // time intervals given by "period"
    const pair$ = zip(timer1$, data$); // Combines elements from timer1$ and data$ into pairs
    return pair$.pipe(pluck(1)); // Yields the 2nd element of each pair generated by pair$
  }

  createObservableThatProcessOneValueAfterWaitTime(
    value: number,
    waitTime: number
  ) {
    return zip(
      timer(waitTime),
      new Observable<number>(observer => {
        observer.next(value * 10);
        observer.complete();
      })
    ).pipe(
      pluck(1),
      startWith(`Processing ${value}`),
      endWith(`Processed ${value}`)
    );
  }

  runObs1() {
    this.obs1$.subscribe(v => this.logToScreen(`Obs1: ${v}`));
  }

  runObs2() {
    this.obs2$.subscribe(v => this.logToScreen(`Obs2: ${v}`));
  }

  concatObs1Obs2() {
    concat(this.obs1$, this.obs2$).subscribe(v =>
      this.logToScreen(`concat: ${v}`)
    );
  }

  mergeObs1Obs2() {
    merge(this.obs1$, this.obs2$).subscribe(v =>
      this.logToScreen(`merge: ${v}`)
    );
  }

  concatMapObs1Obs2() {
    this.obs1$
      .pipe(
        concatMap(v =>
          this.createObservableThatProcessOneValueAfterWaitTime(v, 2000)
        )
      )
      .subscribe(v => this.logToScreen(`concatMap: ${v}`));
  }

  mergeMapObs1Obs2() {
    this.obs1$
      .pipe(
        mergeMap(v =>
          this.createObservableThatProcessOneValueAfterWaitTime(v, 2000)
        )
      )
      .subscribe(v => this.logToScreen(`mergeMap: ${v}`));
  }

  switchMapObs1Obs2() {
    this.obs1$
      .pipe(
        switchMap(v =>
          this.createObservableThatProcessOneValueAfterWaitTime(v, 2000)
        )
      )
      .subscribe(v => this.logToScreen(`switchMap: ${v}`));
  }
}
